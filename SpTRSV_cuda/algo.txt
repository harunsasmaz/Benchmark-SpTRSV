==============================================================================

### SpTRSV Function:   ###

Input: cscCol, cscRow, cscVal, m, n, nnz, x, b, x_ref

device_count = cudaGetDeviceCount()

Unified Memory malloc s_in_degree and s_left_sum
Unified Memory memset s_in_degree and s_left_sum

for each device: 
    cudaMalloc device cols, rows, vals of size N/device_count
    cudaMemcpy related partititon of input cols, rows and vals 
    cudaMalloc b vector with size of N/device_count
    cudaMemcpy b vector of related partititon

for each device:
    Run pre-processing kernel 

for each device:
    cudaDeviceSynchronize()

for each device: 
    cudaMalloc d_in_degree and d_left_sum of size N/device_count
    cudaMemset d_in_degree and d_left_sum to 0
    cudaMalloc x vector with size of N/device_count
    cudaMemset x vector of related partititon to 0

for each device: 
    Run solving kernel

for each device: 
    cudaDeviceSynchronize()

Finally, accumulate results x from each device and compare with actual result.

==============================================================================

###  PRE-PROCESSING KERNEL:  ###

Input: d_cscRows, m, nnz, s_in_degree

- for each nnz that is partitioned for one device, update s_in_degree

==============================================================================

###     SOLVING KERNEL:     ###

Input: d_cols, d_rows, d_vals, d_in_degree, d_left_sum, d_b, d_x, s_in_degree, s_left_sum


- calculate the index of which warp gets which component of x
- calculate the local index of which warp a thread belongs to.
- calculate the local index of a thread in the warp it belongs to.
- calculate the starting index of each block
- calculate the position of the first element in the related column for x_i

- busy wait until all dependencies are met 

for each warp:
    - calculate the related component of x (all threads in a warp calculates the same value)

for each thread in a warp:
    - calculate the starting position of related component of x
    - calculate the ending   position of related component of x
    - in a for loop:
        - each thread gets a rowIdx for the related nnz element in the assigned column
        - each thread checks if this element is in range of its column space (dev_n)
            - if it is, it updates the d_left_sum and d_in_degree (use threadfence here)
            - if not, it updates the s_left_sum and s_in_degree (use threadfence here)

==============================================================================
